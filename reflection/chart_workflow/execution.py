"""Helpers to extract and execute Python code generated by the LLM."""

from __future__ import annotations

import re
from typing import Any, Mapping

from reflection.M2_UGL_1 import utils as legacy_utils

EXECUTE_TAG_PATTERN = re.compile(r"<execute_python>([\s\S]*?)</execute_python>")


def extract_execute_block(text: str) -> str:
    """
    Return the Python source contained between <execute_python> tags.

    Raises
    ------
    ValueError
        If the expected tag structure cannot be found.
    """
    match = EXECUTE_TAG_PATTERN.search(text or "")
    if not match:
        raise ValueError("Unable to locate <execute_python> block in LLM response.")
    return match.group(1).strip()


def ensure_tagged(code: str) -> str:
    """Wrap bare code inside <execute_python> tags if they are missing."""
    return legacy_utils.ensure_execute_python_tags(code)


def execute_python(
    code: str,
    *,
    globals_dict: Mapping[str, Any] | None = None,
) -> dict[str, Any]:
    """
    Execute arbitrary Python in a controlled globals dictionary.

    Parameters
    ----------
    code:
        The Python source to execute. May or may not be wrapped in execution
        tags; both cases are supported.
    globals_dict:
        Objects that should be visible to the generated code (e.g., ``df``).
        The dictionary is copied to avoid mutating the caller's state.

    Returns
    -------
    dict
        The globals dictionary after execution; useful if the generated code
        defines functions or variables that must be inspected later.
    """
    wrapped = ensure_tagged(code)
    source = extract_execute_block(wrapped)
    exec_globals = dict(globals_dict or {})
    compiled = compile(source, filename="<execute_python>", mode="exec")
    exec(compiled, exec_globals)
    return exec_globals
