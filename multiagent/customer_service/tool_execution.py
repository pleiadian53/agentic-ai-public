"""Execution engine for tool-based customer service plans.

This module executes plans generated by tool_planning.py, running tools
in sequence and validating results at each step.
"""

from __future__ import annotations

from typing import Any

from .data_access import CustomerServiceStore
from .tool_registry import run_tools_for_step, run_tool_validation


def execute_plan(
    plan: dict[str, Any],
    store: CustomerServiceStore,
    stop_on_failed_validation: bool = True
) -> dict[str, Any]:
    """Execute a tool-based plan step by step.
    
    This function:
    1. Runs tools in each step sequentially
    2. Validates results using validation tools
    3. Stops on first validation failure (if stop_on_failed_validation=True)
    4. Returns detailed execution report
    
    Args:
        plan: Plan dict with "steps" list, each containing:
              - "step_number": integer
              - "description": string
              - "tools": list of tool specs
              - "validations": list of validation specs
        store: CustomerServiceStore instance to operate on
        stop_on_failed_validation: If True, halt execution on first validation failure
        
    Returns:
        Dict with:
        - "ok": bool (True if all steps succeeded)
        - "steps": list of step execution reports
        - "aborted": bool (True if stopped early due to validation failure)
        - "abort_step": int (step number where execution stopped)
        - "abort_reason": str (reason for stopping)
    """
    # Initialize execution context
    ctx: dict[str, Any] = {
        "__store__": store,
    }
    
    report: dict[str, Any] = {"ok": True, "steps": []}
    
    try:
        for step in plan.get("steps", []):
            step_number = step.get("step_number")
            description = step.get("description", "")
            
            # Execute tools in this step
            tool_error = None
            try:
                ran = run_tools_for_step(step, ctx)
            except Exception as e:
                ran = {}
                tool_error = str(e)
                report["ok"] = False
            
            # Run validations
            validations = [
                run_tool_validation(v, ctx)
                for v in step.get("validations", [])
            ]
            
            # Check if step succeeded
            step_ok = (tool_error is None) and all(v.get("ok", False) for v in validations)
            if not step_ok:
                report["ok"] = False
            
            # Record step execution
            report["steps"].append({
                "step_number": step_number,
                "description": description,
                "tools_run": list(ran.keys()),
                "tool_error": tool_error,
                "validations": validations,
                "step_ok": step_ok,
            })
            
            # Stop execution if validation failed and stop_on_failed_validation is True
            if stop_on_failed_validation and any(not v.get("ok", False) for v in validations):
                report["aborted"] = True
                report["abort_step"] = step_number
                report["abort_reason"] = "validation_failed"
                break
    
    except Exception as e:
        report["ok"] = False
        report["error"] = str(e)
    
    return report


def execute_plan_with_summary(
    plan: dict[str, Any],
    store: CustomerServiceStore,
    stop_on_failed_validation: bool = True
) -> dict[str, Any]:
    """Execute plan and return summary with success status and message.
    
    This is a convenience wrapper around execute_plan that provides
    a simpler interface for common use cases.
    
    Args:
        plan: Tool-based plan to execute
        store: CustomerServiceStore instance
        stop_on_failed_validation: Whether to stop on first validation failure
        
    Returns:
        Dict with:
        - "success": bool
        - "message": str (human-readable summary)
        - "report": dict (full execution report)
        - "inventory_rows": list (current inventory state)
        - "transaction_rows": list (current transaction state)
    """
    report = execute_plan(plan, store, stop_on_failed_validation)
    
    # Generate summary message
    if report["ok"]:
        message = f"Successfully executed {len(report['steps'])} steps."
    elif report.get("aborted"):
        message = (
            f"Execution stopped at step {report['abort_step']} "
            f"due to {report['abort_reason']}."
        )
    else:
        failed_steps = [
            s["step_number"]
            for s in report["steps"]
            if not s.get("step_ok", False)
        ]
        message = f"Execution failed at step(s): {failed_steps}"
    
    return {
        "success": report["ok"],
        "message": message,
        "report": report,
        "inventory_rows": store.get_inventory_rows(),
        "transaction_rows": store.get_transaction_rows(),
    }


def format_execution_report(report: dict[str, Any]) -> str:
    """Format execution report as human-readable text.
    
    Args:
        report: Execution report from execute_plan
        
    Returns:
        Formatted string representation
    """
    lines = []
    lines.append(f"Overall Status: {'SUCCESS' if report['ok'] else 'FAILED'}")
    lines.append("")
    
    for step_report in report.get("steps", []):
        step_num = step_report["step_number"]
        desc = step_report["description"]
        step_ok = step_report.get("step_ok", False)
        
        lines.append(f"Step {step_num}: {desc}")
        lines.append(f"  Status: {'✓ SUCCESS' if step_ok else '✗ FAILED'}")
        
        if step_report.get("tool_error"):
            lines.append(f"  Tool Error: {step_report['tool_error']}")
        
        if step_report.get("tools_run"):
            lines.append(f"  Tools Run: {', '.join(step_report['tools_run'])}")
        
        validations = step_report.get("validations", [])
        if validations:
            lines.append("  Validations:")
            for v in validations:
                status = "✓" if v.get("ok") else "✗"
                name = v.get("name", "unnamed")
                lines.append(f"    {status} {name}")
                if not v.get("ok") and v.get("error"):
                    lines.append(f"      Error: {v['error']}")
        
        lines.append("")
    
    if report.get("aborted"):
        lines.append(f"⚠ Execution aborted at step {report['abort_step']}")
        lines.append(f"  Reason: {report['abort_reason']}")
    
    return "\n".join(lines)
